-- Mandate Zero game schema
-- Run this in Supabase SQL Editor before using the protected game flow.

create extension if not exists pgcrypto;

create table if not exists public.games (
  id text primary key,
  name text not null,
  created_at timestamptz not null default now()
);

create table if not exists public.players (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  game_id text not null references public.games(id) on delete cascade,
  character_data jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  unique (user_id, game_id),
  constraint players_character_data_object check (jsonb_typeof(character_data) = 'object')
);

create table if not exists public.actions (
  id bigint generated by default as identity primary key,
  game_id text not null references public.games(id) on delete cascade,
  player_id uuid not null references public.players(id) on delete cascade,
  tick_target integer not null check (tick_target > 0),
  type text not null check (char_length(type) > 0 and char_length(type) <= 64),
  payload jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default now(),
  constraint actions_payload_object check (jsonb_typeof(payload) = 'object')
);

create index if not exists players_user_game_idx on public.players (user_id, game_id);
create index if not exists actions_game_tick_idx on public.actions (game_id, tick_target);
create index if not exists actions_player_idx on public.actions (player_id);

create or replace function public.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

drop trigger if exists players_set_updated_at on public.players;
create trigger players_set_updated_at
before update on public.players
for each row execute procedure public.set_updated_at();

alter table public.games enable row level security;
alter table public.players enable row level security;
alter table public.actions enable row level security;

drop policy if exists "Authenticated users can read games" on public.games;
create policy "Authenticated users can read games"
on public.games
for select
to authenticated
using (true);

drop policy if exists "Users can read own players" on public.players;
create policy "Users can read own players"
on public.players
for select
to authenticated
using (auth.uid() = user_id);

drop policy if exists "Users can insert own players" on public.players;
create policy "Users can insert own players"
on public.players
for insert
to authenticated
with check (auth.uid() = user_id);

drop policy if exists "Users can update own players" on public.players;
create policy "Users can update own players"
on public.players
for update
to authenticated
using (auth.uid() = user_id)
with check (auth.uid() = user_id);

drop policy if exists "Users can delete own players" on public.players;
create policy "Users can delete own players"
on public.players
for delete
to authenticated
using (auth.uid() = user_id);

drop policy if exists "Users can read own actions" on public.actions;
create policy "Users can read own actions"
on public.actions
for select
to authenticated
using (
  exists (
    select 1
    from public.players p
    where p.id = actions.player_id
      and p.user_id = auth.uid()
  )
);

drop policy if exists "Users can insert actions for own player" on public.actions;
create policy "Users can insert actions for own player"
on public.actions
for insert
to authenticated
with check (
  exists (
    select 1
    from public.players p
    where p.id = actions.player_id
      and p.user_id = auth.uid()
      and p.game_id = actions.game_id
  )
);

insert into public.games (id, name)
values ('demo-game-id', 'Demo Game')
on conflict (id) do nothing;
